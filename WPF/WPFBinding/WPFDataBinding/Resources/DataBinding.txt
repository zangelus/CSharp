Data Binding

Data Binding Intro

Virtually every meaningful application deals with data in one form or another. One of the challenges that has faced application developers has been how to attach that data to the view, to the user interface. Data Binding in WPF is a powerful tool to automate the connection between data and the view of that data. It tremendously reduces the amount of code, simplifies your application development, greatly enhances reliability, and is the foundation for MVVM that we'll be discussing later in this course. The simplest form of Data Binding is One Way Binding, in which data is bound from its source (that is the object that holds the data) to its target (that is the object that displays the data). In Two Way Binding, the user is able to modify the data through the user interface and have that data updated in the source. If the source changes while the user is looking at the view, you want the view to be updated. The INotifyPropertyChanged interface facilitates updating the view when the underlying data changes. It is also possible to bind, not to a standard data source, but rather to another element on the page. When you are binding, you are going to be binding properties of your data source to your data target. The Data Context is the source itself and says, this is the object whose properties you're binding from. You can bind not only individual pieces of data, but collections of data and these can be bound to controls such as list boxes and combo boxes. When you do, you will need to tell the list what part of the data to display and you will do that with Data Templates. At times, the data does not lend itself to the display control. The types are too different and the display is inappropriate for the type of data. Data binding in WPF supports Data Conversion, which converts the data at the source to the type expected at the target. Another important aspect of data binding is ensuring that the data is valid. Many of the data binding controls support Data Validation. As you can see there's a great deal to data binding. Let's look at a series of demos that will illustrate each of these points.

One Way Data Binding Demo

To get started looking at data binding, we'll create a new WPF project and call it DataBindingOneWay. This will illustrate One Way Binding; after a little bit, we'll also illustrate Two Way Binding. In order to illustrate binding, we need a binding source. Typically that's some form of POCO, Plain Old CLR Object. In order to get such an object we'll need to declare a class and an instance of that class. Let's go to the project and say Add, Class, and we will add an Employee class. As soon as that comes up, we will mark our Employee class public and we will give our Employee class two public properties - the first will be the name of the employee and the second will be the employee's title. In addition, we will give our class a static method called GetEmployee, which will instantiate an employee and return it. This class will act as a stand-in for obtaining an employee from a database or from a web service. (Typing) With our Employee class in place, we are now ready to create a form that will display that employee. Let's turn to MainWindow.xaml. In MainWindow.xaml, we automatically have a grid, we're going to place a StackPanel into that grid, and we will give our StackPanel a name. Inside the StackPanel, we're going to create two more stack panels, each with the orientation of horizontal so that we can have a prompt and a value. The first inner StackPanel, we will add Orientation="Horizontal" and inside that we will add a TextBlock and we will set that Text="Name: " and that will serve as a prompt. The second TextBlock will have a margin of 5 on the left and remember the margin is left, top, right, bottom, if you are putting in four values, but for the text we want to bind to the name property of our Employee object and so we use a special syntax — open curly brace, the keyword Binding, and then the name of the property that we're binding to. That's it for our first inner StackPanel. Our second inner StackPanel is very, very similar, except that the prompt says Title and we bind to the title. Notice that we are binding to a property, name or title, but we have not designated what object that property belongs to. To do so, we need to set the data context. There are a number of ways of setting the data context. One very easy way is to turn to the Code Behind and in the constructor, after we initialize component, we can say DataContext equal to and now we want to call that static GetEmployee method of the Employee class. And that will return an Employee object and that Employee object will be the DataContext whose properties we are binding to. Let's run this application and you can see immediately in our MainWindow that we have successfully bound to the Name and Title of that Employee object.

INPC Demo

It is possible that more than one person will be editing or adjusting the data that is displayed in our program. If the underlying data changes, we want our view to be updated. To do that, let's return to our Employee class, where we will implement the INotifyPropertyChanged interface. INotifyPropertyChanged requires that we add a using statement for SystemComponentModel and it requires that we implement an event. The event we must implement is called PropertyChanged; it is of type PropertyChangedEventHandler. We're going to call PropertyChanged each time one of our properties is updated. To facilitate that, we're going to use a helper method called OnPropertyChanged. OnPropertyChanged uses the CallerMemberName and that requires a using statement for System.Runtime.CompilerServices and what that does is it passes in the name of the property that calls this method. Unfortunately, we can no longer use automatic properties because we need to call the OnPropertyChanged method every time we call the setter. Thus, we will create a backing variable for each of the properties and in the setter, we will call OnPropertyChanged after assigning the passed in value to the underlying backing variable. We've done that for Name, let's do that for Title. Now our view will be updated if the underlying data changes, but how will we know that; how can we test that? Let's go and modify our main page just a bit. Here we have, as you remember, an outer StackPanel with two inner stack panels and after the second inner StackPanel, we are now going to add a button and for that button we will add a Click event handler. In the Button_Click event handler, which is in the Code Behind, we're going to make a little change to the logic rather than having the DataContext set in the constructor as it is now with whatever we get back from GetEmployee. We're going instead to create a private member variable of type Employee, which we'll call emp. In the constructor, we'll go ahead and instantiate that employee and in the Button_Click event handler, we're going to reassign the Name and the Title of that employee and we can do that simply by saying emp.Name equal and giving it a different value and then we can say emp.Title equals and setting a value for the title. That will mimic the effect of the data changing while it's being displayed in our One Way Binding. Before we run that, we do have to set of course the DataContext, so let's come back to the constructor and say that the DataContext is equal to emp. Let's run the application. And notice we get our initial name and title and a great big Change button. We're not going to change the Name and Title through this interface, but instead we're going to mimic at changing in the underlying data, and as soon as it does, our view is updated because of INotifyPropertyChanged.

Two Way Data Binding Demo

We now have One Way Data Binding working with INotifyPropertyChanged. I've made a copy of the project. Let's rename the project from DataBindingOneWay to DataBindingTwoWay and let's go ahead and rename the solution as well from DataBindingOneWay to DataBindingTwoWay. We'll then change the namespace from DataBindingOneWay to DataBindingTwoWay, confirm the refactoring, and with that done, all of the files are updated and we have a new project name — DataBindingTwoWay. We can run it just to make sure that it continues to work. We see the initial values, click the Change button, everything is working. We're now ready to look at Two Way Data Binding. To do that, we're going to go back to our main window and we need to make two changes. Right now we are displaying the Name and the Title with text blocks. We're going to need to change those to text boxes so that we can have an interaction with the user and we're going to need to update the binding statement. Let's start by changing the first TextBlock for Name to a TextBox and then in the binding statement we'll add a Mode statement; notice the different modes come up and the one we want is two way, the default is one way. We then want to do the same for Title. We can get rid of the button, but how will we know that the underlying data has been updated? The easiest way to do that is to add two more inner stack panels and bind them one way to the Name and the Title and they'll be updated when the underlying data is updated because of INotifyPropertyChanged. That's all we have to do. We don't have to do anything to the underlying data or anything else in the program; simply changing the binding mode to two way and using an interactive control, in this case a TextBox. Let's run the program, program comes up, and we can see they're now in textboxes. If I click in the first TextBox and change the value, as soon as I tab out of that box, the underlying data is changed and we see that in the TextBlock below that that's immediately updated. I can do the same thing with the Title. We can change that to Evangelist and as soon as I tab out, the underlying value is updated. That's the essence of Two Way Binding. It allows us not only to bind for display, but also to allow the user to update the data interactively while your application is running.

Data Binding Lists Demo

When data binding to lists, you face somewhat different challenges than when data binding to individual objects. To see what's involved, let's create a new project called DataBindingLists. We'll begin by creating, once again, an Employee class and our Employee class will be identical to the one that we had before, except that we're going to add a new static method called GetEmployees plural. GetEmployees is going to create an ObservableCollection. Let's add the necessary using statements all around. An ObservableCollection is much like an object that implements INotifyPropertyChanged. With an ObservableCollection, the view will be notified of any addition to or deletion from the collection. By putting observable objects inside an ObservableCollection, any change whatsoever will be sent to the view. Our GetEmployees method creates a new ObservableCollection and then adds five employees, setting the Name and Title of each, and returns that collection. Let's turn to our view in MainWindow.xaml and what we are going to do in the Grid is create a ComboBox. The ItemsSource property is what is used for binding a collection to a ComboBox or list box or other display for lists. You can set the ItemsSource in your Code Behind or you can bind it as we're doing here and that's just to bind it to whatever is set as the DataContext. I'm going to set the FontSize to 30 to make the entries a little bit larger and I'll set the Height and Width of the ComboBox itself. If all I do is create the ComboBox and then go to the Code Behind and set the DataContext=Employee.GetEmployees and run the application, we've not quite given it enough information. It knows to get its ItemsSource from the Employee's collection, but when we open it up, all we find is 1, 2, 3, 4, 5, five Employee objects, but it has no idea what to display about those Employee objects. For that we need to give it a little bit of help and we do that with a template. Let's return to the XAML and inside the ComboBox between the opening and closing tag, we're going to add a ComboBox.ItemTemplate, and ItemTemplate describes what each item should look like. The ItemTemplate that is supported is a DataTemplate and inside the DataTemplate, we simply create the XAML for an individual item and that will be repeated for each item. In our case, we're going to have a horizontal StackPanel with the prompt and the name and then the title with a prompt. So the first thing we add to the ComboBox is a StackPanel, whose orientation is horizontal, we set a small margin of 2, and then we have a TextBlock to act as the prompt for the name, a TextBlock that binds to the name, and in this case it will bind to the Name property of each object in turn in the collection, then a prompt for the Title and a TextBlock to bind to the title. Let's run the application again. And now we get a ComboBox that has the contents as we intended and we can pick any of these and make it the current item in the ComboBox.

Element Data Binding Demo

At times, rather than binding to the value of an object, you may decide you'd like to bind to another element on the page. Let's create an application called element binding and we will create a Horizontal StackPanel, in which we're going to put side by side a Slider and a TextBlock. We'll give the Slider a name, we'll set its Minimum value and its Maximum value, and we will set its Width. With the Slider in place, we're going to go ahead and add a TextBlock, we'll give the TextBlock a Margin of 5 to put a little bit of room between the two, and when we're setting the Text we're going to bind that to the value property of the Slider using the ElementName property to determine where we're obtaining the value. Here we're obtaining it from another element named mySlider. Before we run that, let's be sure to capitalize the v in value and run our application and now we see the Slider with the value next to it, and as we slide, the value is instantly updated because it is bound to the value of the slider. So the TextBlock shows the value of the Slider at each location.

Data Conversion Demo

There are times when the data that you wish to bind does not match the display you wish to use. Let's create an application called DataConverterDemo and take a look at what you can do under those conditions. We begin by recreating our Employee class; this time and most significant, we've added a startDate of type DateTime. We still have the name and the title and the PropertyChangedEventHandler. Let's return to our view and all we wish to do is to display the Name, Title, and startDate. So we'll create an outer StackPanel and then an inner StackPanel with our Name and Title as we've seen before. Now let's create a third inner StackPanel to hold the startDate. The prompt is the same, it's a TextBlock, it says startDate, and then we're going to add a second TextBlock, give it a small margin on the left to leave a little bit of room, set the Height and Width, and we're going to set the Text to bind to the StartDate, but this time we want to add a converter. We don't want the StartDate to just display as a DateTime would if we hit ToString, we want to take control of that, and so we're going to add a class to our solution, we will call DateConverter. DateConverter will implement the interface IValueConverter. First thing we need to do is add the necessary using statement, but now we can also ask the interface to stub out the required members and you can see that there are two required members for IValueConverter - a method convert and a method convert back. Each of them takes four properties - the value, the targetType, a parameter, and a CultureInfo object. Convert is very simple. We're going to take the value and convert it to a DateTime and then we're going to call ToString with the formatting that we like. If we convert back, we're going to parse the string and attempt to turn it into a DateTime object. We can save that. To begin, we need to set a local namespace, which we will set to the namespace for this application. We can then create a Windows.Resources section and in that, using the local namespace, we find DateConverter, that's the class we just created, and we'll create a key for that DateConverter, which we will call DateConverter. That creates a resource that points to our DateConverter. We can now come down to our TextBlock and what we're going to do is to set the converter equal to the StaticResource that we just created — DateConverter. Run the application and the reason we have no date or entry is that we have not set up the DataContext. In this particular case, we have not created the GetEmployee object so we will instantiate a new employee object and we will pass in to the constructor, the first name, the title, and a DateTime object for the startDate, which in this case will be July 10, 2001. We can now set our DataContext to that Employee object, run the application, and this time we do see the name, the title, and a properly formatted startDate and that date is formatted properly because of the DateConverter we created.

Summary

In this module we looked at one of the most powerful and important features in WPF and that is data binding. We looked at One Way Binding, as well as Two Way Binding, and we saw how changes to the underlying data can be reflected in the view through the INotifyPropertyChanged interface. We also saw that you can bind from one element to another and we saw the importance of the Data Context for identifying which object is the object whose properties are being bound. We took a look at how to handle binding to lists and collections and how to use Data Templates to control the appearance of each item in a list. Finally, we took a look at data converters that are used to automatically convert the data from one format or type to another during binding.